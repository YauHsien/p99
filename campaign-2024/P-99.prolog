% P01 (*): to find the last element of a given list.
%
% my_last(?X, ?List).

my_last(X, [X]).
my_last(X, [_|T]) :-
    my_last(X, T).

% P02 (*): to find the last but one element of a given list.
%
% last_but_one(?X, ?List).

last_but_one(X, [X,_]).
last_but_one(X, [_|T]) :-
    last_but_one(X, T).

% P03 (*): to find the k-th element of a given list.
%
% element_at(?X, ?List, ?K): K is a number at least number 1.

element_at(X, [X|_], 1).
element_at(X, [_|T], K+1) :-
    element_at(X, T, K).

% P04 (*): to find the number of elements of a given list.
%
% count(?List, ?Count).

count(List, Count) :-
    var(List),
    ground(Count), !,
    element_at(_, List, Count),
    count(List, Count), !.
count([], 0).
count([_|T], Count) :-
    count(T, C0),
    Count is C0 + 1.

% P05 (*): to reverse a list.
%
% reverse(?List, ?Reverse).
%
% partial_reverse/3: given a list and a number n,
%       when the n-th element occurs in the list,
%       the element also occur in the reverse of the list.

reverse(List, Reverse) :-
    count(List, N),
    count(Reverse, N),
    partial_reverse(List, N, Reverse), !.

partial_reverse([], 0, _).
partial_reverse([H|T], N, Reverse) :-
    element_at(H, Reverse, N),
    N2 is N - 1,
    partial_reverse(T, N2, Reverse).


% P06 (*): to determine if a given list is a palindrome.
%
% palindrome(+List).

palindrome(List) :-
    reverse(List, List).


% P07 (**): to flatten a nested list structure.
%
% my_flatten(+List, ?Flatten).

my_flatten([], []).
my_flatten([L|T], F) :-
    is_list(L), !,
    append(L, T, List),
    my_flatten(List, F).
my_flatten([H|T], [H|F]) :-
    my_flatten(T, F).

% P08 (**): to eliminate consecutive duplicates of list elements.
%
% compress(+List, ?Compressed).

compress([], []).
compress([H,H|T], C) :- !,
    compress([H|T], C).
compress([H|T], [H|C]) :-
    compress(T, C).

% P09 (**): to pack consecutive duplicates of list elements into sublists.
%
% pack(+List, ?Pack).
%
% Example:
% :- pack([a,a,a,a,b,c,c,a,a,d,e,e,e,e], [[a,a,a,a],[b],[c,c],[a,a],[d],[e,e,e,e]]).

pack([], []).
pack([H,H|T], [[H|R]|P]) :- !,
    pack([H|T], [R|P]).
pack([H|T], [[H]|P]) :-
    pack(T, P).

% P10 (*): run-length encoding of a list by using result of pack/2.
%
% encode(+List, ?Encoding).
%
% Example:
% :- encode([a,a,a,a,b,c,c,a,a,d,e,e,e,e], [[4,a],[1,b],[2,c],[2,a],[1,d],[4,e]]).
% by using result of pack/2:
% :- pack([a,a,a,a,b,c,c,a,a,d,e,e,e,e], [[a,a,a,a],[b],[c,c],[a,a],[d],[e,e,e,e]]).

encode(List, Encoding) :-
    pack(List, Pack),
    encode_pack(Pack, Encoding).

encode_pack([], []).
encode_pack([[H|R]|T], [[N,H]|E]) :-
    count([H|R], N),
    encode_pack(T, E).

% P11 (*): modified run-length encoding.
%
% encode_modified(+List, ?Encoding).

encode_modified(List, Encoding) :-
    pack(List, Pack),
    encode_pack_modified(Pack, Encoding).

encode_pack_modified([], []).
encode_pack_modified([[H|R]|T], [X|E]) :-
    count([H|R], N),
    ( N =:= 1, !,
      X = H
    ; X = [N,H]
    ),
    encode_pack_modified(T, E).

% P12 (**): decode a run-length encoding list generated by encode_modified/2.
%
% decode(+Encoding, ?List).

decode([], []).
decode([[1,H]|E], [H|T]) :- !,
    decode(E, T).
decode([[N,H]|E], [H|T]) :- !,
    M is N - 1,
    decode([[M,H]|E], T).
decode([H|E], [H|T]) :-
    decode(E, T).

% P13 (**): to build a run-length encoding list directly.
%
% encode_direct(+List, ?Encoding).

encode_direct([], []).
encode_direct([H,H|T], [[N,H]|E]) :-
    encode_direct([H|T], [[N0,H]|E]), !,
    N is N0 + 1.
encode_direct([H,H|T], [[2,H]|E]) :-
    encode_direct([H|T], [H|E]).
encode_direct([H|T], [H|E]) :-
    encode_direct(T, E).

% P14 (*): to duplicate the elements of a list.
%
% dupli(?List, ?Dupli).

dupli([], []).
dupli([H|T], [H,H|R]) :-
    dupli(T, R).

% P15 (**): to duplicate the elements of a list a given number of times.
%
% dupli(+List, +N, ?Dupli).
%
% Note #1:
% After the its first result, the following query will enter long loop.
% ?- dupli(X, 3, [a,a,a,b,b,b]).
% X = [a, b] ;
%
% Note:
% ?- dupli(X,3,Y).
% X = Y, Y = [] ;
% X = [_A],
% Y = [_A, _A, _A] ;
% X = [_A, _B],
% Y = [_A, _A, _A, _B, _B, _B] ;
% X = [_A, _B, _C],
% Y = [_A, _A, _A, _B, _B, _B, _C, _C, _C] .

dupli(List, N, Dupli) :-
    times(List, N, Times),
    decode(Times, Dupli).

times([], _, []).
times([H|T], N, [[N,H]|M]) :-
    times(T, N, M).

% P16 (**): to drop every n-th element from a given list.
%
% drop(?List, +N, ?Result).

drop(List, N, Result) :-
    count(List, C),
    M is C rem N,
    drop(List, N, M, Result).

drop(List, N, M, Result) :-
    count(List, C),
    ( C =< M, !,
      Result = List
    ; C rem N =:= 2, !,
      [_|List2] = List,
      drop(List2, N, M, Result)
    ; [H|List2] = List,
      drop(List2, N, M, R),
      Result = [H|R]
    ).

% P17 (*): to split a list into two parts;
%      the length of the first part is given as +N.
%      No predefined predicates are used.
%
% split(?List, +N, ?First, ?Second).

split(List, N, [], List) :- N =< 0, !.
split(List, N, First, Second) :-
    split(List, N, [], First, Second).

split([H|T], N, Acc, First, Second) :-
    count(Acc, M),
    N > M, !,
    split(T, N, [H|Acc], First, Second).
split(List, _, Acc, First, List) :-
    reverse(Acc, First).

% P18 (**): to extract a slice from a list.
%
% slice(+List, +N, +M, ?Slice).

slice(List, N, M, Slice) :-
    split(List, N-1, _, Rest),
    split(Rest, M-N+1, Slice, _).

% P19 (**): to rotate a list N places to the left.
%
% rotate(?List, +N, ?Rotate).
%
% Note:
% Move N elements leftward when N is a positive number.
% :- rotate([a,b,c,d], 3, X).
% X = [d,a,b,c].
%
% Move N elements rightward when N is a negative number.

rotate(List, N, Rotate) :-
    N >= 0, !,
    split(List, N, First, Second),
    append(Second, First, Rotate).
rotate(List, N, Rotate) :-
    M is abs(N),
    rotate(Rotate, M, List).

% P20 (*): to remove K-th element from a list.
%
% remove_at(?Element, ?List, +K, ?Result).

remove_at(Element, List, K, Result) :-
    split(List, K-1, First, Second),
    ( Second == [], !,
      Element = nothing,
      Result = First
    ; [Element|T] = Second,
      append(First, T, Result)
    ).

% P21 (*): to insert an element at a given position into a list.
%
% insert_at(?Element, ?List, +K, ?Result).

insert_at(Element, List, K, Result) :-
    split(List, K-1, First, Second),
    my_flatten([First,[Element],Second], Result).

% P22 (*): to create a list containing all integers within a given range.
%
% range(+N, +M, +Rage).

range(N, M, [X|T]) :-
    N < M, !,
    X is N,
    range(N+1, M, T).
range(N, M, [M]) :- N =:= M.

% P23 (**): to take a randomly selected element from a list.
%
% rnd_select(+List, +N, -Select).

rnd_select(List, N, Select) :-
    is_list(List), !,
    p23(List, N, Select).
rnd_select(N, M, Select) :-
    p24(N, M, Select).

p23(_, N, []) :-
    N =< 0, !.
p23(List, N, [X|Select]) :-
    count(List, C),
    C2 is C + 1,
    random(1, C2, R),
    remove_at(X, List, R, List2),
    p23(List2, N-1, Select).

:- List = [a,b,c,d,e,f,g,h],
   rnd_select(List, 3, [A,B,C]),
   member(A, List),
   member(B, List),
   member(C, List), !,
   writeln('test :- rnd_select(L,3,[_,_,_]).: OK')
   ; writeln('test :- rnd_select(L,3,[_,_,_]).: not pass').

% P24 (*): to drow N different random numbers from the set 1..M.
%
% rnd_select(+N, +M, -Select).

p24(N, M, Select) :-
    range(1, M, List),
    p23(List, N, Select).

:- rnd_select(3, 49, [A,B,C]),
   range(1, 49, L),
   member(A, L),
   member(B, L),
   member(C, L),
   writeln('test :- rnd_select(3,49,[_,_,_]).: OK')
   ; writeln('test :- rnd_select(3,49,[_,_,_]).: not pass').

% P25 (*): to draw a random permutation of elements of a list.
%
% rnd_permu(+List, -Permu).

rnd_permu(List, Permu) :-
    count(List, Count),
    rnd_select(List, Count, Permu).

% P26 (**): to generate the combinations of K distinct objects chosen from the N elements of a list.
%
% combination(+K, ?List, ?Combination).

combination(K, _, []) :- K =:= 0.
combination(K, [H|List], [H|Combination]) :-
    K > 0,
    combination(K-1, List, Combination).
combination(K, [_|List], Combination) :-
    K > 0,
    combination(K, List, Combination).

% P27 (**): to group the elements of a set into disjoint subsets.
%
% P27-1: to group the elements of a set into disjoint subgroups of 2, 3, and 4 elements.
%
% group3(?List, ?G1, ?G2, ?G3).

group3(List, [A,B], [C,D,E], [F,G,H,I]) :-
    combination(2, List, [A,B]),
    combination(3, List, [C,D,E]),
    \+ member(A, [C,D,E]),
    \+ member(B, [C,D,E]),
    combination(4, List, [F,G,H,I]),
    \+ member(A, [F,G,H,I]),
    \+ member(B, [F,G,H,I]),
    \+ member(C, [F,G,H,I]),
    \+ member(D, [F,G,H,I]),
    \+ member(E, [F,G,H,I]).

% P27-2: to group the elements of a set into disjoint subgroups of specified group sizes.
%
% group(+List, +Sizes, ?Groups).

group(List, Sizes, Groups) :-
    count(List, Count),
    sum_list(Sizes, Count),
    group_(List, Sizes, Groups).

group_(_, [], []) :- !.
group_(List, [N|Sizes], [G|Groups]) :-
    combination(N, List, G),
    except(List, G, List2),
    group_(List2, Sizes, Groups).

except(List, [], List).
except([H|T], [H|R], List) :- !,
    except(T, R, List).
except(List, [_|R], Result) :-
    except(List, R, Result).

% P28 (**): to sort a list of lists according to length of sublists.
%
% P28-1: to sort a list of lists according to length of each element.
%
% lsort(+List, ?Sort).

lsort([], []).
lsort([H|T], Sort) :-
    lsort_partition(T, H, G1, G2),
    lsort(G1, S1),
    lsort(G2, S2),
    append([S1,[H],S2], Sort).

lsort_partition([], _, [], []).
lsort_partition([H|T], X, [H|G1], G2) :-
    count(H, C1),
    count(X, C2),
    C1 =< C2, !,
    lsort_partition(T, X, G1, G2).
lsort_partition([H|T], X, G1, [H|G2]) :-
    lsort_partition(T, X, G1, G2).

% P28-2: to sort a list of lists according to length frequency of each element.
%
% lfsort(+List, ?Sort).

lfsort(List, Sort) :-
    freq_map(List, Map),
    lfsort(List, Map, Sort).

lfsort([], _, []).
lfsort([H|T], Map, Sort) :-
    lfsort_partition(T, H, Map, G1, G2),
    lfsort(G1, Map, S1),
    lfsort(G2, Map, S2),
    append([S1,[H],S2], Sort).

lfsort_partition([], _, _, [], []).
lfsort_partition([H|T], X, Map, [H|G1], G2) :-
    count(H, C1),
    count(X, C2),
    freq(C1, Map, F1),
    freq(C2, Map, F2),
    F1 =< F2, !,
    lfsort_partition(T, X, Map, G1, G2).
lfsort_partition([H|T], X, Map, G1, [H|G2]) :-
    lfsort_partition(T, X, Map, G1, G2).

freq_map(List, Map) :-
    lsort(List, Sort),
    maplist([A,B]>> count(A,B), Sort, List2),
    encode(List2, Map).

freq(C, [[F,C]|_], F) :- !.
freq(C, [_|Map], F) :-
    freq(C, Map, F).

% P31 (**): to determine whether a given integer number is prime.
%
% is_prime(+N).

is_prime(2) :- !.
is_prime(3) :- !.
is_prime(N) :- N < 2, !, fail.
is_prime(N) :-
    M is sqrt(N),
    N2 is floor(M),
    range(2, N2, R),
    forall(member(X,R), N rem X =\= 0).

:- findall(
       X,
       ( member(X,[2,3,4,5,6,7,8,9,10,11,12,13,14]),
         is_prime(X)),
       [2,3,5,7,11,13]
   ),
   writeln('test :- findall(X,(member(X,2..14),is_prime(X)),[2,3,5,7,11,13]).: OK')
   ; writeln('test :- findall(X,(member(X,2..14),is_prime(X)),[2,3,5,7,11,13]).: not pass').

% P32 (**): to find the greatest common divisor of two positive integer numbers.
%
% gcd(+N, +M, -GCD), where N and M are positive integers.

gcd(N, M, GCD) :-
    N < M, !,
    gcd(M, N, GCD).
gcd(N, M, GCD) :-
    integer(N), N > 0,
    integer(M), M > 0,
    R is N rem M,
    ( R =:= 0, !,
      GCD = M
    ; gcd(M, R, GCD)
    ).

:- arithmetic_function(gcd/2).

:- gcd(36, 63, 9), !, writeln('test :- gcd(36,63,9).: OK')
   ; writeln('test :- gcd(36,63,9).: not pass').

:- G is gcd(36, 63), G =:= 9, !,
   writeln('test :- G is gcd(36,63), G =:= 9.: OK')
   ; writeln('test :- G is gcd(36,63), G =:= 9.: not pass').

% P33 (*): to determine two positive integer numbers are coprime.
%
% coprime(+N, +M).

coprime(N, M) :-
    integer(N), N > 0,
    integer(M), M > 0,
    gcd(N, M, 1).

:- coprime(35, 64), !, writeln('test :- coprime(35,64).: OK')
   ; writeln('test :- coprime(35,64).: not pass').

% P34 (**): to calculate Euler's totient function.
%
% phi(+M, ?TotientCount).

totient_phi(1, 1) :- !.
totient_phi(M, C) :-
    M > 1,
    M0 is M - 1,
    findall(
        X,
        ( between(1, M0, X),
          coprime(X, M)
        ),
        L),
    count(L, C).

:- arithmetic_function(totient_phi/1).

:- Phi is totient_phi(10), Phi =:= 4, !,
   writeln('test :- Phi is totient_phi(10), Phi =:= 4.: OK')
   ; writeln('test :- Phi is totient_phi(10), Phi =:= 4.: not pass').

% P35 (**): to find the prime factors of a given positive integer.
%
% prime_factors(+Int, -Factors).

prime_factors(N, L) :-
    integer(N), N > 0,
    prime_factors(N, 2, L).

prime_factors(N, N, [N]) :- !.
prime_factors(N, M, L) :-
    gcd(N, M, 1), !,
    M2 is M + 1,
    prime_factors(N, M2, L).
prime_factors(N, M, [M|L]) :-
    N2 is N div M,
    prime_factors(N2, M, L).

:- prime_factors(315, [3,3,5,7]), !,
   writeln('test :- prime_factors(315,[3,3,5,7]).: OK')
   ; writeln('test :- prime_factors(315,[3,3,5,7]).: not pass').

% P36 (**): to find the prime factors of a given positive integer. (2)
%
% prime_factors_mult(+Int, -Factors).

prime_factors_mult(N, L) :-
    integer(N), N > 0,
    prime_factors_mult(N, 2, L).

prime_factors_mult(N, N, [[N,1]]) :- !.
prime_factors_mult(N, M, L) :-
    gcd(N, M, 1), !,
    M2 is M + 1,
    prime_factors_mult(N, M2, L).
prime_factors_mult(N, M, [[M,C]|L]) :-
    N2 is N div M,
    prime_factors_mult(N2, M, [[M,C0]|L]), !,
    C is C0 + 1.
prime_factors_mult(N, M, [[M,1]|L]) :-
    N2 is N div M,
    prime_factors_mult(N2, M, L).

:- prime_factors_mult(315, [[3,2],[5,1],[7,1]]), !,
   writeln('test :- prime_factors_mult(315,[[3,2],[5,1],[7,1]]).: OK')
   ; writeln('test :- prime_factors_mult(315,[[3,2],[5,1],[7,1]]).: not pass').

% P37 (**): an improved version of P34, to calculate Euler's totient function phi(m).
%
% phi(+M, ?Result).

phi(1, 1) :- !.
phi(M, R) :-
    M > 1,
    prime_factors_mult(M, L),
    maplist([[N,C],(N-1)*N**(C-1)]>>true, L, R0),
    mult_list(R0, R).

mult_list([], 1).
mult_list([H|T], R) :-
    mult_list(T, R0),
    R is H * R0.

:- arithmetic_function(phi/1).

:- 4 is phi(10), !, writeln('test :- 4 is phi(10).: OK')
   ; writeln('test :- 4 is phi(10.: not pass)').

% P38 (*): comparison between P34 and P37.

:- writeln('P38: performance of :- totient_phi(10090,_).'), time(totient_phi(10090,_)).

:- writeln('P38: performance of :- phi(10090,_).'), time(phi(10090,_)).

% P39 (*): to take a list of prime numbers in a given range of integers.
%
% prime_number_between(+N, +M, +Prime).

prime_number_between(N, M, Prime) :-
    N > M, !,
    prime_number_between(M, N, Prime).
prime_number_between(N, M, Prime) :-
    integer(N), N > 0,
    integer(M), M > 0,
    between(N, M, Prime),
    is_prime(Prime).

% P40 (**): to calculate Goldbach's conjecture.
%
% goldbach(+N, ?L).

goldbach(N, [A,B]) :-
    N > 2,
    N0 is N div 2,
    prime_number_between(2, N0, A),
    B is N - A,
    is_prime(B).

:- goldbach(28, [5,23]), !,
   writeln('test :- goldbach(28,[5,23]).: OK')
   ; writeln('test :- goldbach(28,[5,23]).: not pass').

% P41 (**): a list of Goldbach compositions.
%
% goldbach_list(+N, +M).
% goldbach_list(+N, +M, +Limit): N and M are both bigger than the Limit number.

goldbach_list(N, M) :-
    N =< 2, !,
    goldbach_list(3, M).
goldbach_list(N, M) :- N > M, !.
goldbach_list(N, M) :-
    integer(N), N > 0,
    integer(M), M > 0,
    N rem 2 =:= 0,
    once(goldbach(N, [A,B])),
    format("~p = ~p + ~p~n", [N, A, B]),
    N2 is N + 1,
    goldbach_list(N2, M).
goldbach_list(N, M) :-
    N rem 2 =\= 0,
    N2 is N + 1,
    goldbach_list(N2, M).

goldbach(N, [A,B], Limit) :-
    goldbach(N, [A,B]),
    A > Limit,
    B > Limit.

goldbach_list(N, M, L) :-
    N =< 2, !,
    goldbach_list(3, M, L).
goldbach_list(N, M, _) :- N > M, !.
goldbach_list(N, M, L) :-
    integer(N), N > 0,
    integer(M), M > 0,
    N rem 2 =:= 0,
    ( once(goldbach(N, [A,B], L)),
      format("~p = ~p + ~p~n", [N, A, B])
    ; true
    ),
    N2 is N + 1,
    goldbach_list(N2, M, L).
goldbach_list(N, M, L) :-
    N rem 2 =\= 0,
    N2 is N + 1,
    goldbach_list(N2, M, L).

% P46 (**): truth tables for logical expressions.
%
% and(+A, +B).
% or(+A, +B).
% nand(+A, +B).
% nor(+A, +B).
% impl(+A, +B).
% equ(+A, +B).
%
% table(+A, +B, +C), where predicate C may contain both variables A and B.

and(A, B) :- A, B.

or(A, _) :- A, !.
or(_, A) :- A.

nand(A, B) :- A, B, !, fail.
nand(_, _).

nor(A, _) :- A, !, fail.
nor(_, A) :- A, !, fail.
nor(_, _).

impl(A, _) :- \+ A, !.
impl(_, A) :- A.

equ(A, B) :-
    impl(A, B),
    impl(B, A).

table(A, B, C) :-
    foreach(case(A,B,C), true).

case(A, B, C) :-
    var(A),
    var(B),
    member(A, [true,false]),
    member(B, [true,false]),
    true_fail(A, P1),
    true_fail(B, P2),
    true_fail(C, P3),
    format("~p ~p ~p~n", [P1,P2,P3]).

true_fail(E, 'true') :- call(E), !.
true_fail(_, 'fail').

:- writeln(':- table(A, B, and(A,or(A,B)))'), table(A, B, and(A,or(A,B))).

% P47 (*): truth tables for logical expressions. (2)

not(A) :- A, !, fail.
not(_).

:- op(900, fy, \+),
   op(500, yfx, [+,-,/\,\/,xor]),
   op(500, xfx, [and,nand]),
   op(499, xfx, [or,nor]),
   op(501, fx, not),
   op(500, fx, ?),
   op(1200, xfx, [equ, impl]).

:- writeln(':- table(A, B, A and (A or (not B)))'), table(A, B, A and (A or (not B))).

% P48 (**): truth tables for logical expressions. (3)

table(List, Predicate) :-
    foreach(p48(List, [], Predicate), true).

p48([], Acc, L) :-
    reverse([L|Acc], K),
    case(K).
p48([H|T], Acc, L) :-
    member(H, [true,false]),
    p48(T, [H|Acc], L).

case(List) :-
    foreach(( member(X,List),
              true_fail(X, P),
              format("~p ", [P])
            ),
            true),
    writeln('\n').

:- writeln(':- table([A,B,C], (A and (B or C)) equ (A and B or (A and C))).'),
   table([A,B,C], (A and (B or C)) equ (A and B or (A and C))).

% P49 (**): gray code.

gray(N, '0') :- N =:= 1.
gray(N, '1') :- N =:= 1.
gray(N, C) :-
    N > 1,
    gray(N-1, C0),
    ( atom_concat('0', C0, C)
    ; atom_concat('1', C0, C)
    ).

:- table(gray/2).

% P50 (***): Huffman code.
%
% huffman(Fs, Hs).
%
% Example:
% ?- huffman(
%  [fr(a,45),fr(b,13),fr(c,12),fr(d,16),fr(e,9),fr(f,5)],
%  [hc(a,'0'), hc(b,'101'), hc(c,'100'), hc(d,'111'),
%   hc(e,'1101'), hc(f,'1100')]
% ).
%
% Note:
% For each round two elements are chosen, such as
% fr(e,9) and fr(f, 5),
% and their will be combined to
% fr([hc(e,'1'), hc(f,'0')], 9+5).

huffman([fr(Hs,_)], Hs).
huffman([A,B|T], Hs) :-
    List = [A,B|T],
    fsort(List, [A0,B0|T0]),
    join(A0, B0, C0),
    huffman([C0|T0], Hs).

fsort([], []).
fsort([H|T], Sort) :-
    fsort_partition(T, H, G1, G2),
    fsort(G1, S1),
    fsort(G2, S2),
    my_flatten([S1,[H],S2], Sort).

fsort_partition([], _, [], []).
fsort_partition([fr(A,B)|T], fr(C,D), [fr(A,B)|G1], G2) :-
    B =< D, !,
    fsort_partition(T, fr(C,D), G1, G2).
fsort_partition([fr(A,B)|T], fr(C,D), G1, [fr(A,B)|G2]) :-
    fsort_partition(T, fr(C,D), G1, G2).

hsort([], []).
hsort([H|T], Sort) :-
    hsort_partition(T, H, G1, G2),
    hsort(G1, S1),
    hsort(G2, S2),
    my_flatten([S1,[H],S2], Sort).

hsort_partition([], _, [], []).
hsort_partition([hc(A,B)|T], hc(C,D), [hc(A,B)|G1], G2) :-
    atom_codes(A,C1),
    atom_codes(C,C2),
    C1 =< C2, !,
    hsort_partition(T, hc(C,D), G1, G2).
hsort_partition([hc(A,B)|T], hc(C,D), G1, [hc(A,B)|G2]) :-
    hsort_partition(T, hc(C,D), G1, G2).

join(fr(A,B), fr(C,D), fr(K,B+D)) :-
    B > D, !,
    join(C, A, K).
join(fr(A,B), fr(C,D), fr(K,B+D)) :- !,
    join(A, C, K).
join(A, B, C) :-
    is_list(A), is_list(B), !,
    findall(X, (member(E,A),promote(E,'0',X)), A2),
    findall(X, (member(E,B),promote(E,'1',X)), B2),
    append(A2, B2, C).
join(A, B, C) :-
    is_list(A), \+ is_list(B), !,
    findall(X, (member(E,A),promote(E,'0',X)), A2),
    append(A2, [hc(B,'1')], C).
join(A, B, C) :-
    \+ is_list(A), is_list(B), !,
    findall(X, (member(E,B),promote(E,'1',X)), B2),
    append([hc(A,'0')], B2, C).
join(A, B, [hc(A,'0'),hc(B,'1')]).

promote(hc(A,B), T, hc(A,C)) :-
    member(T, ['0','1']),
    atom_concat(T, B, C).

:- huffman([fr(a,45),fr(b,13),fr(c,12),fr(d,16),fr(e,9),fr(f,5)],Hs),
   hsort(Hs,[hc(a,'0'), hc(b,'101'), hc(c,'100'), hc(d,'111'), hc(e,'1101'), hc(f,'1100')] ), !,
   writeln('test :-  huffman([fr(a,45),fr(b,13),fr(c,12),fr(d,16),fr(e,9),fr(f,5)],[hc(a,\'0\'), hc(b,\'101\'), hc(c,\'100\'), hc(d,\'111\'), hc(e,\'1101\'), hc(f,\'1100\')]).: OK')
   ; writeln('test :-  huffman([fr(a,45),fr(b,13),fr(c,12),fr(d,16),fr(e,9),fr(f,5)],[hc(a,\'0\'), hc(b,\'101\'), hc(c,\'100\'), hc(d,\'111\'), hc(e,\'1101\'), hc(f,\'1100\')]).: not pass').

% P54 (*): to determine if a term is tree.
%
% istree(+A).
%
% Note:
% An empty tree is nil.
% A root without subtrees is t(_,nil,nil).

istree(nil).
istree(t(_,L,R)) :-
    istree(L),
    istree(R).

:- istree(t(a,t(b,nil,nil),nil)), !, writeln('test :- istree(t(a,t(b,nil,nil),nil)).: OK')
   ; write('test :- istree(t(a,t(b,nil,nil),nil)).: not pass').


:- istree(t(a,t(b,nil,nil))), !, writeln('test :- istree(t(a,t(b,nil,nil))).: not pass')
   ; writeln('test :- istree(t(a,t(b,nil,nil))). (it won\'t pass): OK').

% P55 (**): to construct completely balanced binary trees.
%
% cbal_tree(+N, ?Tree), where N is a given number of nodes.

cbal_tree(N, nil) :- N =:= 0.
cbal_tree(N, t(x,nil,nil)) :- N =:= 1.
cbal_tree(N, t(x,A,B)) :-
    N > 1,
    N2 is N div 2,
    N =:= N2 + N2,
    ( cbal_tree(N2-1, A),
      cbal_tree(N2, B)
    ; cbal_tree(N2, A),
      cbal_tree(N2-1, B)
    ).
cbal_tree(N, t(x,A,B)) :-
    N > 1,
    N2 is N div 2,
    N =:= N2 + N2 + 1,
    cbal_tree(N2, A),
    cbal_tree(N2, B).

% P56 (**): to check whether a binary tree is symmetric.
%
% symmetric(+T).
%
% Note
% By using a helper predicate mirror(+T, +Mirror), which will create a mirror tree of a tree.

symmetric(nil).
symmetric(t(_,A,B)) :-
    mirror(A, B).

mirror(nil, nil).
mirror(t(A,L,R), t(A,L2,R2)) :-
    mirror(L, R2),
    mirror(R, L2).

% P57 (**): to construct a binary search tree.
%
% construct(+List, ?T).

construct(List, Tree) :-
    construct(List, nil, Tree).

construct([], Tree, Tree).
construct([H|T], Acc, Tree) :-
    add_to_tree(H, Acc, Acc2),
    construct(T, Acc2, Tree).

add_to_tree(X, nil, t(X,nil,nil)).
add_to_tree(X, t(A,B,C), t(A,B2,C)) :-
    X =< A, !,
    add_to_tree(X, B, B2).
add_to_tree(X, t(A,B,C), t(A,B,C2)) :-
    add_to_tree(X, C, C2).

:- construct([3,2,5,7,1], t(3,t(2,t(1,nil,nil),nil),t(5,nil,t(7,nil,nil)))), !,
   writeln('test :- construct([3,2,5,7,1], t(3,t(2,t(1,nil,nil),nil),t(5,nil,t(7,nil,nil)))).: OK')
   ; writeln('test :- construct([3,2,5,7,1], t(3,t(2,t(1,nil,nil),nil),t(5,nil,t(7,nil,nil)))).: not pass').

% P58 (**): to generate a symmetic completely balanced binary tree by generate-and-test paradigm.
%
% sym_cbal_trees(+N, ?Trees).

sym_cbal_trees(N, Ts) :-
    findall(T, (cbal_tree(N,T),symmetric(T)), Ts).

:- writeln('How many symmetric completely balanced binary trees are there with 57 nodes?'),
   sym_cbal_trees(57, Ts), count(Ts, Count),
   format("Answer: ~p~n", [Count]).

% P59 (**): to generate a height-balanced binary tree.
%
% hbal_tree(+Height, ?Tree).

hbal_tree(N, nil) :- N =:= 0.
hbal_tree(N, t(x,nil,nil)) :- N =:= 1.
hbal_tree(N, t(x,A,B)) :-
    N > 1,
    ( N1 = N-1, N2 = N-1
    ; N1 = N-1, N2 = N-2
    ; N1 = N-2, N2 = N-1
    ),
    hbal_tree(N1, A),
    hbal_tree(N2, B).

% P60 (**): to construct a height-balanced binary tree with a given number of nodes.
%
% hbal_tree_nodes(+N, ?Tree).
%
% Note:
% minNodes(+H, ?N), where N is the minimum number of nodes in a height-balanced binary tree of height H.
% maxHeight(+N, ?H), where by given N nodes, the maxiumin height of a height-balanced binary tree will be built.

hbal_tree_nodes(N, nil) :- N =:= 0.
hbal_tree_nodes(N, t(x,nil,nil)) :- N =:= 1.
hbal_tree_nodes(N, t(x,A,B)) :-
    N > 1,
    maxHeight(N, H),
    ( H1 = H-1, H2 = H-1
    ; H1 = H-1, H2 = H-2
    ; H1 = H-2, H2 = H-1
    ),
    minNodes(H1, H1N), H1M is 2**H1 - 1,
    minNodes(H2, H2N), H2M is 2**H2 - 1,
    between(H1N, H1M, P),
    between(H2N, H2M, Q),
    P + Q =:= N - 1,
    hbal_tree_nodes(P, A),
    hbal_tree_nodes(Q, B).

minNodes(H, 0) :- H =:= 0, !.
minNodes(H, 1) :- H =:= 1, !.
minNodes(H, N) :-
    H > 1,
    minNodes(H-1, N1),
    minNodes(H-2, N2),
    N is 1 + N1 + N2.

maxHeight(N, 0) :- N =:= 0, !.
maxHeight(N, 1) :- N =:= 1, !.
maxHeight(N, H) :-
    N > 1,
    N0 is N - 1,
    ( N0 rem 2 =:= 0, !,
      maxHeight(N0 / 2, H2),
      H is H2 + 1
    ; maxHeight(N0 div 2, H1),
      maxHeight(N0 div 2 + 1, H2),
      H is 1 + max(H1,H2)
    ).

:- writeln('How many height-balanced trees exist for N = 15.'),
   findall(T, hbal_tree_nodes(15,T), Ts), count(Ts, Count),
   format("Answer: ~p~n", [Count]).

% P61 (*): to count the leaves of a binary tree.
%
% count_leaves(+Tree, ?N).

count_leaves(nil, 0).
count_leaves(t(x,A,B), N) :-
    count_leaves(A, N1),
    count_leaves(B, N2),
    N is 1 + N1 + N2.

% P61A (*): to collect the leaves of a binary tree in a list.
%
% leaves(+Tree, -List).

leaves(nil, []).
leaves(t(X,A,B), L) :-
    leaves(A, C),
    leaves(B, D),
    append([C,[X],D], L).

% P62 (*): to collect the internal nodes of a binary tree in a list.
%
% internals(+Tree, -List).

internals(nil, []).
internals(t(_,nil,nil), []) :- !.
internals(t(X,A,B), L) :-
    internals(A, C),
    internals(B, D),
    append([C,[X],D], L).

% P62B (*): to collect the nodes at a given level of a binary tree in a list.
%
% atlevel(+Tree, +Level, -List).

atlevel(nil, _, []).
atlevel(t(X,_,_), N, [X]) :- N =:= 1.
atlevel(t(_,A,B), N, L) :-
    N > 1,
    atlevel(A, N-1, C),
    atlevel(B, N-1, D),
    append(C, D, L).

% P63 (**): to construct a complete binary tree.

complete_binary_tree(N, nil) :- N =:= 0.
complete_binary_tree(N, t(x,nil,nil)) :- N =:= 1.
complete_binary_tree(N, t(x,A,B)) :-
    N > 1,
    fit_level(N, L),
    N0 is 2**(L-1) - 1,
    F is 2**(L-1) / 2,
    H is N0 div 2,
    ( N - N0 =< F, !,
      complete_binary_tree(H + N - N0, A),
      complete_binary_tree(H, B)
    ; complete_binary_tree(H + F, A),
      complete_binary_tree(H + N - N0 - F, B)
    ).

fit_level(N, L) :-
    fit_level(N, 1, L).

fit_level(N, M, L) :-
    2**(M-1) =< N,
    N < 2**M, !,
    L is M.
fit_level(N, M, L) :-
    2**M =< N,
    fit_level(N, M+1, L).

% P64 (**): to generate a positioned binary tree.
%
% layout_binary_tree(+Tree, ?PositionedTree).

layout_binary_tree(Tree, Result) :-
    inorder_traversal(Tree, Map),
    layout_binary_tree(Tree, Map, 1, Result).

layout_binary_tree(nil, _, _, []).
layout_binary_tree(t(X,A,B), Map, N, t(X,I,Y,C,D)) :-
    element_at(X, Map, I0),
    I is I0,
    Y is N,
    layout_binary_tree(A, Map, N+1, C),
    layout_binary_tree(B, Map, N+1, D).

inorder_traversal(nil, []).
inorder_traversal(t(X,A,B), List) :-
    inorder_traversal(A, C),
    inorder_traversal(B, D),
    append([C,[X],D], List).

example_tree(t(n,t(k,t(c,t(a,nil,nil),t(h,t(g,t(e,nil,nil),nil),nil)),t(m,nil,nil)),t(u,t(p,nil,t(s,t(q,nil,nil),nil)),nil))).

p64_result(t(n, 8, 1, t(k, 6, 2, t(c, 2, 3, t(a, 1, 4, [], []), t(h, 5, 4, t(g, 4, 5, t(e, 3, 6, [], []), []), [])), t(m, 7, 3, [], [])), t(u, 12, 2, t(p, 9, 3, [], t(s, 11, 4, t(q, 10, 5, [], []), [])), []))).

:- example_tree(T), p64_result(P), layout_binary_tree(T,P), !,
   writeln('test :- layout_binary_tree(t(n,t(k,t(c,t(a,nil,nil),t(h,t(g,t(e,nil,nil),nil),nil)),t(m,nil,nil)),t(u,t(p,nil,t(s,t(q,nil,nil),nil)),nil)), t(n, 8, 1, t(k, 6, 2, t(c, 2, 3, t(a, 1, 4, [], []), t(h, 5, 4, t(g, 4, 5, t(e, 3, 6, [], []), []), [])), t(m, 7, 3, [], [])), t(u, 12, 2, t(p, 9, 3, [], t(s, 11, 4, t(q, 10, 5, [], []), [])), []))).: OK')
   ; writeln('test :- layout_binary_tree(t(n,t(k,t(c,t(a,nil,nil),t(h,t(g,t(e,nil,nil),nil),nil)),t(m,nil,nil)),t(u,t(p,nil,t(s,t(q,nil,nil),nil)),nil)), t(n, 8, 1, t(k, 6, 2, t(c, 2, 3, t(a, 1, 4, [], []), t(h, 5, 4, t(g, 4, 5, t(e, 3, 6, [], []), []), [])), t(m, 7, 3, [], [])), t(u, 12, 2, t(p, 9, 3, [], t(s, 11, 4, t(q, 10, 5, [], []), [])), []))).: not pass').

% P65 (**): to generate a positioned binary tree in constant horizontal distance.
%
% layout_binary_tree_2(+Tree, ?PositionedTree).

layout_binary_tree_2(Tree, PositionedTree) :-
    tree_height(Tree, Height),
    layout_binary_tree_2(Tree, Height, _, 1, T),
    tree_left(T, L),
    duplicate_term(L, L0),
    term_variables(L0, [0]),
    term_variables(L, [1-L0]),
    normal_p_tree(T, PositionedTree).

layout_binary_tree_2(nil, _, _, _, nil).
layout_binary_tree_2(t(A,B,C), Height, X, Y, t(A,X,Y,E,F)) :-
    D = (2**(Height-Y-1)),
    layout_binary_tree_2(B, Height, X-D, Y+1, E),
    layout_binary_tree_2(C, Height, X+D, Y+1, F).

tree_height(nil, 0).
tree_height(t(_,nil,nil), 1) :- !.
tree_height(t(_,A,B), H) :-
    tree_height(A, C),
    tree_height(B, D),
    H is 1 + max(C, D).

tree_left(t(_,X,_,nil,_), X).
tree_left(t(_,_,_,A,_), L) :-
    tree_left(A, L).

normal_p_tree(nil, nil).
normal_p_tree(t(A,B,C,D,E), t(A,B2,C2,D2,E2)) :-
    B2 is B,
    C2 is C,
    normal_p_tree(D, D2),
    normal_p_tree(E, E2).

p65_example_tree(t(n,t(k,t(c,t(a,nil,nil),t(e,t(d,nil,nil),t(g,nil,nil))),t(m,nil,nil)),t(u,t(p,nil,t(q,nil,nil)),nil))).

p65_result(t(n,15,1,t(k,7,2,t(c,3,3,t(a,1,4,nil,nil),t(e,5,4,t(d,4,5,nil,nil),t(g,6,5,nil,nil))),t(m,11,3,nil,nil)),t(u,23,2,t(p,19,3,nil,t(q,21,4,nil,nil)),nil))).

:- p65_example_tree(T), p65_result(P), layout_binary_tree_2(T,P), !,
   writeln('test :- layout_binary_tree_2(t(n,t(k,t(c,t(a,nil,nil),t(e,t(d,nil,nil),t(g,nil,nil))),t(m,nil,nil)),t(u,t(p,nil,t(q,nil,nil)),nil)), t(n,15,1,t(k,7,2,t(c,3,3,t(a,1,4,nil,nil),t(e,5,4,t(d,4,5,nil,nil),t(g,6,5,nil,nil))),t(m,11,3,nil,nil)),t(u,23,2,t(p,19,3,nil,t(q,21,4,nil,nil)),nil))).: OK')
   ; writeln('test :- layout_binary_tree_2(t(n,t(k,t(c,t(a,nil,nil),t(e,t(d,nil,nil),t(g,nil,nil))),t(m,nil,nil)),t(u,t(p,nil,t(q,nil,nil)),nil)), t(n,15,1,t(k,7,2,t(c,3,3,t(a,1,4,nil,nil),t(e,5,4,t(d,4,5,nil,nil),t(g,6,5,nil,nil))),t(m,11,3,nil,nil)),t(u,23,2,t(p,19,3,nil,t(q,21,4,nil,nil)),nil))).: not pass').

% P66 (**): to generate a positioned binary tree in condensed distance.
%
% layout_binary_tree_3(+Tree, ?PositionedTree).

layout_binary_tree_3(Tree, PositionedTree) :-
    p66(Tree, _, 1, T, _),
    tree_left(T, L),
    duplicate_term(L, L0),
    term_variables(L0, [0]),
    term_variables(L, [1-L0]),
    normal_p_tree(T, PositionedTree).

p66(nil, _, _, nil, []).
p66(t(A,B,nil), X, Y, t(A,X,Y,E,nil), L) :- !,
    p66(B, X-1, Y+1, E, L).
p66(t(A,nil,B), X, Y, t(A,X,Y,nil,E), L) :- !,
    p66(B, X+1, Y+1, E, L).
p66(t(A,t(B,nil,nil),C), X, Y, t(A,X,Y,t(B,X-1,Y+1,nil,nil),F), L) :- !,
    p66(C, X+1, Y+1, F, L).
p66(t(A,B,t(C,nil,nil)), X, Y, t(A,X,Y,E,t(C,X+1,Y+1,nil,nil)), L) :- !,
    p66(B, X-1, Y+1, E, L).
p66(t(A,B,C), X, Y, t(A,X,Y,E,F), L) :-
    I = X - D,
    J = X + D,
    D is 2, % FAKE <-------------------------------- I FAKEd that for reasons.
    p66(B, I, Y+1, E, L1),
    p66(C, J, Y+1, F, L2),
    node(B, B0),
    node(C, C0),
    append([L2,L1,[(B0,C0)]], L).
%    distance(D, E, F).

node(t(X,_,_), X).

p66_result(t(n, 5, 1, t(k, 3, 2, t(c, 2, 3, t(a, 1, 4, nil, nil), t(e, 3, 4, t(d, 2, 5, nil, nil), t(g, 4, 5, nil, nil))), t(m, 4, 3, nil, nil)), t(u, 7, 2, t(p, 6, 3, nil, t(q, 7, 4, nil, nil)), nil))).

:- p65_example_tree(T), layout_binary_tree_3(T, P),
   p66_result(P),
   !,
   writeln('test :- p65_example_tree(T), layout_binary_tree_3(T, t(n, 5, 1, t(k, 3, 2, t(c, 2, 3, t(a, 1, 4, nil, nil), t(e, 3, 4, t(d, 2, 5, nil, nil), t(g, 4, 5, nil, nil))), t(m, 4, 3, nil, nil)), t(u, 7, 2, t(p, 6, 3, nil, t(q, 7, 4, nil, nil)), nil))).: OK')
   ; writeln('test :- p65_example_tree(T), layout_binary_tree_3(T, t(n, 5, 1, t(k, 3, 2, t(c, 2, 3, t(a, 1, 4, nil, nil), t(e, 3, 4, t(d, 2, 5, nil, nil), t(g, 4, 5, nil, nil))), t(m, 4, 3, nil, nil)), t(u, 7, 2, t(p, 6, 3, nil, t(q, 7, 4, nil, nil)), nil))).: not pass').

% P67 (**): to convert a tree to a string, and another does this inverse.
%
% (a)
% tree_string(?Tree, ?String).

tree_string(T, S) :-
    ground(T), !,
    tree_nlist(T, S0),
    my_flatten(S0, F),
    string_codes(S, F).
tree_string(T, S) :-
    ground(S), !,
    string_codes(S, C),
    codes_tree(C, _, [], T).

tree_nlist(nil, []).
tree_nlist(t(X,nil,nil), X0) :- !,
    atom_codes(X, [X0]).
tree_nlist(t(X,L,R), [X0,40,A,44,B,41]) :-
    atom_codes(X, [X0]),
    tree_nlist(L, A),
    tree_nlist(R, B).

codes_tree([], N, [T], T) :- N = nil.
codes_tree([], N, [T0,t(X,K,nil)|Acc], T) :-
    codes_tree([], N, [t(X,K,T0)|Acc], T).
codes_tree([H,40|List], N, Acc, T) :-
    atom_codes(H0, [H]),
    codes_tree(List, N, [t(H0,nil,nil)|Acc], T).
codes_tree([H,44|List], N, [t(X,nil,K)|Acc], T) :-
    atom_codes(H0, [H]),
    codes_tree(List, N, [t(X,H0,K)|Acc], T).
codes_tree([44|List], N, [t(X,nil,K)|Acc], T) :-
    codes_tree(List, N, [t(X,N,K)|Acc], T).
codes_tree([44|List], N, [t(X,K,nil)|Acc], T) :-
    K \= nil,
    codes_tree(List, N, [t(X,K,nil)|Acc], T).
codes_tree([H,41|List], N, [t(X,K,nil)|Acc], T) :-
    H \= 41,
    atom_codes(H0, [H]),
    condensed_acc([t(X,K,H0)|Acc], Acc2),
    codes_tree(List, N, Acc2, T).
codes_tree([41|List], N, Acc, T) :-
    condensed_acc(Acc, Acc2),
    codes_tree(List, N, Acc2, T).

condensed_acc([T,t(X,nil,nil)|Acc], Result) :- !,
    condensed_acc([t(X,T,nil)|Acc], Result).
condensed_acc(Acc, Acc).

:- tree_string(t(a,t(b,t(d,nil,nil),t(e,nil,nil)),t(c,nil,t(f,t(g,nil,nil),nil))), "a(b(d,e),c(,f(g,)))"), !,
   writeln('test :- tree_string(t(a,t(b,t(d,nil,nil),t(e,nil,nil)),t(c,nil,t(f,t(g,nil,nil),nil))), "a(b(d,e),c(,f(g,)))").: OK')
   ; writeln('test :- tree_string(t(a,t(b,t(d,nil,nil),t(e,nil,nil)),t(c,nil,t(f,t(g,nil,nil),nil))), "a(b(d,e),c(,f(g,)))").: not pass').

% (b)

tree_string_2(T, S) :-
    ground(T), !,
    tree_dlist(T, L-[]),
    string_codes(S, L).
tree_string_2(T, S) :-
    ground(S), !,
    string_codes(S, C),
    tree_dlist(T, C-[]).

tree_dlist(nil, List-List).
tree_dlist(t(X,nil,nil), [X0|List]-List) :- !,
    atom_codes(X, [X0]).
tree_dlist(t(X,L,R), [X0,40|L0]-List) :-
    atom_codes(X, [X0]),
    tree_dlist(L, L0-[44|R0]),
    tree_dlist(R, R0-[41|List]).

p67_example_tree(t(a,t(b,t(d,nil,nil),t(e,nil,nil)),t(c,nil,t(f,t(g,nil,nil),nil)))).

:- p67_example_tree(T), tree_string_2(T,S), tree_string_2(T2,S), T = T2, !,
   writeln('test :- T = t(a,t(b,t(d,nil,nil),t(e,nil,nil)),t(c,nil,t(f,t(g,nil,nil),nil))), tree_string_2(T,S), tree_string_2(S,T),.: OK')
   ; writeln('test :- T = t(a,t(b,t(d,nil,nil),t(e,nil,nil)),t(c,nil,t(f,t(g,nil,nil),nil))), tree_string_2(T,S), tree_string_2(S,T),.: not pass').

% P68 (**): preorder and inorder sequences of binary trees.
%
% a)
% preorder(+Tree, ?Seq).
% inorder(+Tree, ?Seq).

preorder(nil, '').
preorder(t(X,L,R), S) :-
    var(S), !,
    preorder(L, L0),
    preorder(R, R0),
    atomic_list_concat([X,L0,R0], S).

inorder(nil, '').
inorder(t(X,L,R), S) :-
    var(S), !,
    inorder(L, L0),
    atom_concat(L0, X, P),
    inorder(R, R0),
    atom_concat(P, R0, S).

% b)
%
% A preorder or inorder of a tree can represent trees more than one.
% Then we hanve preorder_tree/2 and inorder_tree/2 to find each tree
% for a preorder or inorder representation.

preorder_tree('', nil).
preorder_tree(S, t(X,L,R)) :-
    atom_concat(X, LR, S),
    atom_length(X, 1),
    atom_concat(L0, R0, LR),
    preorder_tree(L0, L),
    preorder_tree(R0, R).

inorder_tree('', nil).
inorder_tree(S, t(X,L,R)) :-
    atom_concat(L0, XR, S),
    atom_concat(X, R0, XR),
    atom_length(X, 1),
    inorder_tree(L0, L),
    inorder_tree(R0, R).

% c)
%
% pre_in_tree(+Preorder, +Inorder, ?Tree).

pre_in_tree(P, I, Tree) :-
    preorder_tree(P, Tree),
    inorder(Tree, I0),
    I == I0.

% d) Redo a) and c) using difference lists.

preorder_2(T, S) :-
    var(S), !,
    preorder_2(T, S0-[]),
    atomic_list_concat(S0, S).
preorder_2(nil, List-List).
preorder_2(t(X,nil,nil), [X|List]-List) :- !.
preorder_2(t(X,L,R), [X|List]-Rest) :-
    preorder_2(L, List-R0),
    preorder_2(R, R0-Rest).

inorder_2(T, S) :-
    var(S), !,
    inorder_2(T, S-[]).
inorder_2(nil, List-List).
inorder_2(t(X,nil,nil), [X|List]-List) :- !.
inorder_2(t(X,L,R), List-Rest) :-
    inorder_2(L, List-[X|R0]),
    inorder_2(R, R0-Rest).

% ?- p67_example_tree(T), time(inorder(T,R1)), time(inorder_2(T, R)).
% % 29 inferences, 0.000 CPU in 0.000 seconds (0% CPU, Infinite Lips)
% % 10 inferences, 0.000 CPU in 0.000 seconds (0% CPU, Infinite Lips)
% T = t(a, t(b, t(d, nil, nil), t(e, nil, nil)), t(c, nil, t(f, t(g, nil, nil), nil))),
% R1 = dbeacgf,
% R = [d, b, e, a, c, g, f].
%
% ?- p67_example_tree(T), time(preorder(T,R1)), time(preorder_2(T, R)).
% % 22 inferences, 0.000 CPU in 0.000 seconds (0% CPU, Infinite Lips)
% % 10 inferences, 0.000 CPU in 0.000 seconds (0% CPU, Infinite Lips)
% T = t(a, t(b, t(d, nil, nil), t(e, nil, nil)), t(c, nil, t(f, t(g, nil, nil), nil))),
% R1 = abdecfg,
% R = [a, b, d, e, c, f, g].

% P69 (**): preorder again, using dot-string representation.
%
% (1) Insert dots where an empty subtree (nil) is encountered in a preorder or inorder representation.
% (2) Build BNF to define syntax first.
% (3) Use difference lists.
%
% tree_dotstring(+Tree, ?DotString).
%
% BNF:
% Tree       ::= empty-tree | term Tree Tree
% term       ::= a | b | c | d | e | f | g | ... | z
% empty-tree ::= `.`

tree_dotstring(T, S) :-
    var(S), !,
    tree_dotstring(T, S0-[]),
    atomic_list_concat(S0, S).
tree_dotstring(T, S) :-
    atom(S), !,
    atom_chars(S, S0),
    tree_dotstring(T, S0-[]).
tree_dotstring(nil, ['.'|List]-List).
tree_dotstring(t(X,L,R), [X|List]-Rest) :-
    tree_dotstring(L, List-R0),
    tree_dotstring(R, R0-Rest).

appendDL(L-R, R-Y, L-Y).

% P70B (*): to check whether a given term represents a multiway tree.
%
% istree_M(+Tree).

istree_M(t(_,[])).
istree_M(t(_,L)) :-
    is_list(L), L \= [],
    foreach(member(E,L), istree_M(E)).

% P70C (*): to count the nodes of a multiway tree.
%
% nnodes(+Tree, ?N).

nnodes(t(_,[]), 1).
nnodes(t(_,L), N) :-
    L \= [], is_list([]),
    findall(N0, (member(E,L),nnodes(E,N0)), L0),
    sum_list(L0, N2),
    N is N2 + 1.

% P70 (**): multiway tree construction.
%
% tree(?Tree).
%
% BNF:
% Tree    ::= t(element, `[` `]`) | t(element, `[` Forest `]`)
% Forest  ::= Tree | Tree, Forest
% element ::= a | b | c | d | e | f | g
%
% Tree    ::= element Forest `^`
% Forest  ::= `` | Tree | Tree Forest
% element ::= a | b | c | d | e | f | g

multiway_tree(t(A,F), S) :- var(S),
                            multiway_forest(F, F0),
                            atomic_list_concat([A,F0,'^'], S).
multiway_tree(t(A,F), S) :- ground(S),
                            atom_concat(A, R, S), atom_length(A, 1),
                            atom_concat(F0, '^', R),
                            multiway_forest(F, F0).

multiway_forest([], '').
multiway_forest([T|F], S) :- var(S),
                             multiway_tree(T, S0), multiway_forest(F, S2),
                             atom_concat(S0, S2, S).
multiway_forest([T|F], S) :- ground(S),
                             atom_concat(S0, S2, S),
                             multiway_tree(T, S0), multiway_forest(F, S2).

p70_example_tree(t(a,[t(f,[t(g,[])]),t(c,[]),t(b,[t(d,[]),t(e,[])])])).
p70_result('afg^^c^db^e^^^').

% P71 (*): to determine the internal path length of a multiway tree.
%
% ipl(+Tree, -IPL).

ipl(T, N) :- ipl(T, 0, N).

ipl(t(_,[]), N, N) :- !.
ipl(t(_,F), M, N) :- findall(N0, ( member(T, F),
                                   ipl(T, M+1, N0) ), Ns),
                       sum_list([M|Ns], N).

% P72 (*): bottom-up sequence of the nodes of the multiway tree.
%
% bottom_up(+Tree, ?Seq).

bottom_up(T, S) :- p72(T, S-[]), !.

p72(t(A,[]), [A|L]-L).
p72(t(A,[T|F]), L-R) :-
    p72(T, L-R0),
    p72(t(A,F), R0-R), !.

% P73 (**): Lispy token list.
%
% tree_ltl(?Tree, ?LTL).

tree_ltl(T, L) :- ( var(L), !
                  ; is_list(L)
                  ), !,
                  tree_ltl(T, L-[]).
tree_ltl(t(A,[]), [A|L]-L) :- element(A), !.
tree_ltl(t(A,F), ['(',A|L]-R) :- forest_ltl(F, L-[')'|R]).

element(A) :- member(A, [a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z]).

forest_ltl([], L-L).
forest_ltl([T|F], L-R) :- tree_ltl(T, L-R0), forest_ltl(F, R0-R).

% p80 (***): graph conversions.
%
% g2a(+Graph, -AdjacencyList).
% g2h(+Graph, -HumanFriendly).
% a2g(+AdjacencyList, -Graph).
% a2h(+AdjacencyList, -HuamnFriendly). <--
% h2a(+HumanFriendly, -AdjacencyList). <--
% h2g(+HumanFriendly, -Graph).
% d2a(+Digraph, -AdjacencyList).
% d2h(+Digraph, -HumanFriendly).
% a2d(+AdjacencyList, -Digraph).
% a2h/2.
% h2a/2.
% h2d(+HumanFriendly, -Digraph).

g2a(graph([],_), []).
g2a(graph([V|Vs],Es), [n(V,Xs)|As]) :-
    findall(X, (member(e(X0,Y0),Es),(X0==V,X=Y0;Y0==V,X=X0)), Xs),
    g2a(graph(Vs,Es), As).

g2h(graph([],_), []).
g2h(graph([V|Vs],Es), As) :-
    findall(V-X, (member(e(X0,Y0),Es),(X0==V,X=Y0;Y0==V,X=X0)), Xs),
    g2h(graph(Vs,Es), As0),
    findall(X-Y, (member(X-Y,Xs),\+member(X-Y,As0),\+member(Y-X,As0)), Xs0),
    ( Xs == [], !,
      As = [V|As0]
    ; append(Xs0, As0, As)
    ).

a2g([], graph([],[])).
a2g([n(A,Bs)|Ns], graph([A|Vs],Es)) :-
    a2g(Ns, graph(Vs,Es0)),
    findall(e(B,A), (member(B,Bs),\+member(e(A,B),Es0),\+member(e(B,A),Es0)), Es2),
    append(Es2, Es0, Es).

a2h(A, H) :- a2g(A,G), !, g2h(G,H).
a2h(A, H) :- a2d(A,D), !, d2h(D,H).

graph_example(graph([b,c,d,f,g,h,k],[e(b,c),e(b,f),e(c,f),e(f,k),e(g,h)])).


